// Este fichero se le da al alumno
#include <stdio.h>
#include "fichero.h"
#include <math.h>

#define SIZE_NOMBRE_FICHERO	  80
#define DIM 36

typedef struct {
 char sudoku[DIM][DIM];
 int size;
 int ssize;
 int ocupadas;
 int libres;
 int totales;
} tsudoku;


tsudoku leer_sudoku();
void linea_h (int size);
char convertir_char (int i);
void linea_vacia (tsudoku s, int fila);
void mostrar_sudoku(tsudoku s);
void insertar_y_mostrar (tsudoku *c);

int main() {
 int i;
	tsudoku s, caracter;
	s = leer_sudoku();
	mostrar_sudoku(s);
	while (s.libres > 0) {
    insertar_y_mostrar(&s);
}

}

tsudoku leer_sudoku()
{
  int err, f, c, size, car, num1, i, j;
 
        tsudoku s;
	char nombre_fichero[SIZE_NOMBRE_FICHERO];

 s.ocupadas = 0;
 
 s.libres = 0;
 num1 = 0;

	printf("Introduce el nombre del fichero: ");
	scanf("%s%*c", nombre_fichero);
	err = abrir_fichero(nombre_fichero);
	if (err != ABRIR_FICHERO_OK) {
		printf("ERROR: FICHERO NO ENCONTRADO.\n");
		printf("PUEDE QUE EL NOMBRE NO SEA EL CORRECTO O QUE ESTE EN OTRO DIRECTORIO.\n");
	} else {
		s.size = leer_int_fichero();
		s.ssize = sqrt(s.size);
		leer_char_fichero(); // '\n'

		//printf("Sudoku %dx%d\n\n", s.size, s.size);
		for (f = 0; f < s.size; f++) {
			for (c = 0; c < s.size; c++) {
				car = leer_char_fichero();
				s.sudoku[f][c] = car;
			
			}
      if (car >= '1' && car <= '0' + s.size) {
        s.ocupadas++;
      } else if (car == ' ') {
        s.libres++;
      }
			leer_char_fichero(); // '\n'
		}
  printf("\n");
  s.totales = s.size * s.size;
		cerrar_fichero();
	}
  return s;
}
void insertar_y_mostrar(tsudoku *s) {
    int fila, col;
    char valor;
    printf("Intro [fila col car] sin espacios: ");
    scanf("%1d%1d%c%*c", &fila, &col, &valor);
    
     if ((*s).sudoku[fila][col] == ' ') {
      (*s).libres = (*s).libres - 1;
      (*s).ocupadas = (*s).ocupadas + 1;;
    }

    (*s).sudoku[fila][col] = valor;
    mostrar_sudoku(*s);
}


void mostrar_sudoku(tsudoku s)
{
  int f,c;
  printf(" |");
for (c = 0; c < s.size; c++) {
    printf("%c", convertir_char(c));
    if ((c + 1) % s.ssize == 0) {
        printf("|");          
    } else {
        printf(" "); 
    }
}
printf("\n");

  for(f = 0; f < s.size; f++) {
  if(f % (s.ssize) == 0){
    linea_h (s.size);
        printf("%c|", convertir_char(f));
        for(c = 0; c < s.size; c++) {
            printf("%c", s.sudoku[f][c]);
            if((c+1) % s.ssize == 0)
                printf("|");
            else
                printf(" ");
        }
        printf("\n");
    }
    linea_h(s.size);
}
void linea_h (int size) {
 int f,c; 
    printf("-");
     for(c = 0; c < (size * 2); c = c +2){
       printf("+-");
     }
     printf("+\n"); 
  }   
void linea_vacia (tsudoku s, int fila){
int c;
    printf("%c|", convertir_char(fila));
    for (c = 0; c < s.size; c++) {
     if(s.sudoku[fila][c] == ' '){
     printf(" ");
     }else{
        printf("%c", s.sudoku[fila][c]);
        }
        if ((c + 1) % s.ssize == 0) {
            printf("|");
        } else {
            printf(" ");
        }
    }
    printf("\n");
}

char convertir_char (int i) {
 char c;
 if (i < 10){
  c = i + '0';
 }else{
  c = i + 87;
 } 
 return c;
}
/*void insertar_numero(tsudoku *s) {
    int fila, col;
    char valor;

    printf("Introduce fila (0-%d), columna (0-%d) y número (1-%d o espacio para borrar) sin espacios: ",
           s->size - 1, s->size - 1, s->size);

    scanf("%d%d %c%*c", &fila, &col, &valor);

    if (fila < 0 || fila >= s->size || col < 0 || col >= s->size) {
        printf("Posición fuera de rango.\n");
        return;
    }

    char anterior = s->sudoku[fila][col];

    // Actualizar conteo de casillas
    if (anterior >= '1' && anterior <= '0' + s->size) s->ocupadas--;
    if (anterior == ' ') s->libres--;

    // Insertar nuevo valor
    s->sudoku[fila][col] = valor;

    if (valor >= '1' && valor <= '0' + s->size) s->ocupadas++;
    if (valor == ' ') s->libres++;

 */


